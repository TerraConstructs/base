// https://github.com/aws/aws-cdk/blob/v2.186.0/packages/aws-cdk-lib/aws-apigateway/lib/usage-plan.ts

import {
  apiGatewayUsagePlan,
  apiGatewayUsagePlanKey,
} from "@cdktf/provider-aws";
import { Lazy } from "cdktf";
import { Construct } from "constructs";
import { validateDouble, validateInteger } from "./apigateway-util";
import {
  AwsConstructBase,
  AwsConstructProps,
  IAwsConstruct,
} from "../aws-construct";
import { AwsStack } from "../aws-stack";
import { IApiKey } from "../compute/api-key";
import { Method } from "../compute/method";
import { IRestApi } from "../compute/restapi";
import { Stage } from "../compute/stage";

/**
 * Container for defining throttling parameters to API stages or methods.
 * @link https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html
 */
export interface ThrottleSettings {
  /**
   * The API request steady-state rate limit (average requests per second over an extended period of time)
   * @default none
   */
  readonly rateLimit?: number;

  /**
   * The maximum API request rate limit over a time ranging from one to a few seconds.
   * @default none
   */
  readonly burstLimit?: number;
}

/**
 * Time period for which quota settings apply.
 */
export enum Period {
  DAY = "DAY",
  WEEK = "WEEK",
  MONTH = "MONTH",
}

/**
 * Specifies the maximum number of requests that clients can make to API Gateway APIs.
 */
export interface QuotaSettings {
  /**
   * The maximum number of requests that users can make within the specified time period.
   * @default none
   */
  readonly limit?: number;

  /**
   * For the initial time period, the number of requests to subtract from the specified limit.
   * @default none
   */
  readonly offset?: number;

  /**
   * The time period for which the maximum limit of requests applies.
   * @default none
   */
  readonly period?: Period;
}

/**
 * Represents per-method throttling for a resource.
 */
export interface ThrottlingPerMethod {
  /**
   * The method for which you specify the throttling settings.
   */
  readonly method: Method;

  /**
   * Specifies the overall request rate (average requests per second) and burst capacity.
   */
  readonly throttle: ThrottleSettings;
}

/**
 * Type of Usage Plan Key. Currently the only supported type is 'ApiKey'
 */
enum UsagePlanKeyType {
  API_KEY = "API_KEY",
}

/**
 * Represents the API stages that a usage plan applies to.
 */
export interface UsagePlanPerApiStage {
  /**
   * The API to associate with this usage plan stage.
   * @default none
   */
  readonly api?: IRestApi;

  /**
   * The stage to associate with this usage plan.
   * @default none
   */
  readonly stage?: Stage;

  /**
   * Throttle settings for specific methods in this stage.
   * @default none
   */
  readonly throttle?: ThrottlingPerMethod[];
}

export interface UsagePlanProps extends AwsConstructProps {
  /**
   * API Stages to be associated with the usage plan.
   * @default none
   */
  readonly apiStages?: UsagePlanPerApiStage[];

  /**
   * Represents usage plan purpose.
   * @default none
   */
  readonly description?: string;

  /**
   * Number of requests clients can make in a given time period.
   * @default none
   */
  readonly quota?: QuotaSettings;

  /**
   * Overall throttle settings for the API.
   * @default none
   */
  readonly throttle?: ThrottleSettings;

  /**
   * Name for this usage plan.
   * @default - CDK generated name
   */
  readonly name?: string;

  /**
   * ApiKey to be associated with the usage plan.
   * @default none
   * @deprecated use `addApiKey()`
   */
  readonly apiKey?: IApiKey;
}

/**
 * Options to the UsagePlan.addApiKey() method
 */
export interface AddApiKeyOptions {
  /**
   * The construct ID for the UsagePlanKey resource.
   * @default - autogenerated
   */
  readonly overrideLogicalId?: string;
}

export interface UsagePlanOutputs {
  readonly usagePlanId: string;
}

/**
 * A UsagePlan, either managed by this CDK app, or imported.
 */
export interface IUsagePlan extends IAwsConstruct {
  /** Outputs of the usage plan. */
  readonly usagePlanOutputs: UsagePlanOutputs;

  /**
   * Id of the usage plan
   * @attribute
   */
  readonly usagePlanId: string;

  /**
   * Adds an ApiKey.
   *
   * @param apiKey the api key to associate with this usage plan
   * @param options options that control the behaviour of this method
   */
  addApiKey(apiKey: IApiKey, options?: AddApiKeyOptions): void;
}

abstract class UsagePlanBase extends AwsConstructBase implements IUsagePlan {
  /**
   * Id of the usage plan
   * @attribute
   */
  public abstract readonly usagePlanId: string;

  public get usagePlanOutputs(): UsagePlanOutputs {
    return {
      usagePlanId: this.usagePlanId,
    };
  }

  public get outputs(): Record<string, any> {
    return this.usagePlanOutputs;
  }

  /**
   * Adds an ApiKey.
   *
   * @param apiKey the api key to associate with this usage plan
   * @param options options that control the behaviour of this method
   */
  public addApiKey(apiKey: IApiKey, options?: AddApiKeyOptions): void {
    const prefix = "UsagePlanKeyResource";
    // Postfixing apikey id only from the 2nd child.
    const id = this.node.tryFindChild(prefix)
      ? `${prefix}:${AwsStack.uniqueId(apiKey.node)}`
      : prefix;

    const resource = new apiGatewayUsagePlanKey.ApiGatewayUsagePlanKey(
      this,
      id,
      {
        keyId: apiKey.keyId,
        keyType: UsagePlanKeyType.API_KEY,
        usagePlanId: this.usagePlanId,
      },
    );
    if (options?.overrideLogicalId) {
      resource.overrideLogicalId(options.overrideLogicalId);
    }
  }
}

export class UsagePlan extends UsagePlanBase {
  /**
   * Import an externally defined usage plan using its ID.
   *
   * @param scope  the construct that will "own" the imported usage plan.
   * @param id     the id of the imported usage plan in the construct tree.
   * @param usagePlanId the id of an existing usage plan.
   */
  public static fromUsagePlanId(
    scope: Construct,
    id: string,
    usagePlanId: string,
  ): IUsagePlan {
    class Import extends UsagePlanBase {
      public readonly usagePlanId = usagePlanId;
      constructor() {
        super(scope, id);
      }
    }
    return new Import();
  }

  /**
   * @attribute
   */
  public readonly usagePlanId: string;
  private readonly _apiStages = new Array<UsagePlanPerApiStage>();
  private readonly resource: apiGatewayUsagePlan.ApiGatewayUsagePlan;

  constructor(scope: Construct, id: string, props: UsagePlanProps = {}) {
    super(scope, id, props);

    const name = props.name ?? this.stack.uniqueResourceName(this);

    this.resource = new apiGatewayUsagePlan.ApiGatewayUsagePlan(
      this,
      "Resource",
      {
        name,
        description: props.description,
        quotaSettings: this.renderQuota(props.quota),
        throttleSettings: this.renderThrottle(props.throttle),
        apiStages: Lazy.anyValue({
          produce: () =>
            this.renderApiStages()?.map((stage) =>
              apiGatewayUsagePlan.apiGatewayUsagePlanApiStagesToTerraform(
                stage,
              ),
            ),
        }),
      },
    );

    if (props.apiStages) {
      this._apiStages.push(...props.apiStages);
    }

    this.usagePlanId = this.resource.id;

    if (props.apiKey) {
      this.addApiKey(props.apiKey);
    }
  }

  /**
   * Adds an apiStage.
   */
  public addApiStage(apiStage: UsagePlanPerApiStage): void {
    this._apiStages.push(apiStage);
  }

  private renderApiStages():
    | apiGatewayUsagePlan.ApiGatewayUsagePlanApiStages[]
    | undefined {
    if (this._apiStages.length === 0) {
      return undefined;
    }
    return this._apiStages.map((apiStage) => this.createStage(apiStage));
  }

  /**
   * Convert Throttle Per Method to flat array of ApiGatewayUsagePlanApiStagesThrottle
   */
  private renderApiStageThrottles(
    throttles?: ThrottlingPerMethod[],
  ): apiGatewayUsagePlan.ApiGatewayUsagePlanApiStagesThrottle[] | undefined {
    if (!throttles || throttles.length === 0) {
      return undefined;
    }
    // unlike CFN where ApiStageThrottles.throttle is a map (path -> throttle), in TF it is an array
    return throttles.map((tpm) => {
      const renderedThrottle = this.renderThrottle(tpm.throttle);
      if (!renderedThrottle) {
        throw new Error(
          `Throttle settings are undefined for method ${tpm.method.httpMethod} on path ${tpm.method.resource.path}`,
        );
      }
      return {
        path: `${tpm.method.resource.path}/${tpm.method.httpMethod}`,
        burstLimit: renderedThrottle.burstLimit,
        rateLimit: renderedThrottle.rateLimit,
      };
    });
  }

  private createStage(
    apiStage: UsagePlanPerApiStage,
  ): apiGatewayUsagePlan.ApiGatewayUsagePlanApiStages {
    const stageName = apiStage.stage?.stageName;
    const restApiId =
      apiStage.api?.restApiId ?? apiStage.stage?.restApi.restApiId;

    if (!restApiId) {
      throw new Error(
        "Either api or stage (with a restApi) must be provided for an apiStage",
      );
    }
    if (!stageName) {
      throw new Error(
        "Stage must be provided for an apiStage if api is not specified, or if stage is specified it must have a stageName",
      );
    }

    return {
      apiId: restApiId,
      stage: stageName,
      throttle: this.renderApiStageThrottles(apiStage.throttle),
    };
  }

  private renderQuota(
    quota?: QuotaSettings,
  ): apiGatewayUsagePlan.ApiGatewayUsagePlanQuotaSettings | undefined {
    if (quota === undefined) {
      return undefined;
    }
    if (validateInteger(quota.limit, "Throttle quota limit")) {
      return {
        limit: quota.limit,
        offset: quota.offset,
        period: quota.period!,
      };
    }
    return undefined;
  }

  private renderThrottle(
    props?: ThrottleSettings,
  ): apiGatewayUsagePlan.ApiGatewayUsagePlanThrottleSettings | undefined {
    if (props === undefined) {
      return undefined;
    }

    const burstLimit = props.burstLimit;
    validateInteger(burstLimit, "Throttle burst limit");
    const rateLimit = props.rateLimit;
    validateDouble(rateLimit, "Throttle rate limit");

    return {
      burstLimit: props.burstLimit,
      rateLimit: props.rateLimit,
    };
  }
}
